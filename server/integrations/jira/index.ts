import { getLogger } from "@/logger"
import { Subsystem } from "@/types"
import { insert } from "@/search/vespa"
import { createId } from "@paralleldrive/cuid2"

const Logger = getLogger(Subsystem.Integrations).child({
  module: "jiraIntegration",
})

// Define JQL schema constant matching vespa-ts pattern
const JQL_QUERIES_SCHEMA = "jql_queries"

// Create JQL schema object following the vespa-ts pattern
const jqlQueriesSchema = {
  name: JQL_QUERIES_SCHEMA,
  namespace: "default"
}

// TypeScript interface for JQL Query
export interface JQLQuery {
  id: string
  section: string
  nlq: string
  jql: string
  description: string
  query_summary: string
  synonyms: string[]
  paraphrases: string[]
  intents: string[]
  fields: string[]
  entities: string // JSON string
  product: string[]
  why: string
  notes: string
  embedding?: number[] // Optional, can be auto-generated by Vespa
}

// Interface for bulk import
export interface JQLQueryBatch {
  queries: JQLQuery[]
  source?: string
  version?: string
}

// Result interface
export interface JQLInsertResult {
  success: boolean
  inserted: number
  failed: number
  errors: string[]
}

/**
 * Insert a single JQL query into Vespa
 */
export const insertJQLQuery = async (jqlQuery: JQLQuery): Promise<void> => {
  try {
    Logger.info(`Inserting JQL query: ${jqlQuery.id}`)
    
    // Validate required fields
    if (!jqlQuery.id || !jqlQuery.nlq || !jqlQuery.jql) {
      throw new Error("Missing required fields: id, nlq, or jql")
    }
    
    // Ensure entities is a JSON string
    if (typeof jqlQuery.entities === 'object') {
      jqlQuery.entities = JSON.stringify(jqlQuery.entities)
    }
    
    // Create proper Vespa document with required fields
    const vespaDocument = {
      docId: `jql_${jqlQuery.id}`, // Generate proper document ID
      ...jqlQuery
    }
    
    // Insert into Vespa using the correct schema string constant
    await insert(vespaDocument as any, JQL_QUERIES_SCHEMA as any)
    
    Logger.info(`Successfully inserted JQL query: ${jqlQuery.id}`)
  } catch (error) {
    Logger.error(error, `Failed to insert JQL query: ${jqlQuery.id}`)
    throw error
  }
}

/**
 * Insert multiple JQL queries in batch
 */
export const insertJQLQueryBatch = async (
  queries: JQLQuery[]
): Promise<JQLInsertResult> => {
  Logger.info(`Starting batch insert of ${queries.length} JQL queries`)
  
  let inserted = 0
  let failed = 0
  const errors: string[] = []
  
  for (const query of queries) {
    try {
      await insertJQLQuery(query)
      inserted++
    } catch (error) {
      failed++
      const errorMsg = `Query ${query.id}: ${error instanceof Error ? error.message : String(error)}`
      errors.push(errorMsg)
      Logger.error(error, `Failed to insert query ${query.id}`)
    }
  }
  
  Logger.info(`Batch insert completed: ${inserted} successful, ${failed} failed`)
  
  return {
    success: failed === 0,
    inserted,
    failed,
    errors
  }
}

/**
 * Load JQL queries from JSON file or object
 */
export const loadJQLQueriesFromJSON = async (
  jsonData: any[]
): Promise<JQLQuery[]> => {
  const queries: JQLQuery[] = []
  
  for (const item of jsonData) {
    try {
      // Transform the data to match our schema
      const query: JQLQuery = {
        id: item.id || createId(),
        section: item.section || "General",
        nlq: item.nlq,
        jql: item.jql,
        description: item.description || item.nlq,
        query_summary: item.summary || item.query_summary || item.description || item.nlq,
        synonyms: Array.isArray(item.synonyms) ? item.synonyms : [],
        paraphrases: Array.isArray(item.paraphrases) ? item.paraphrases : [],
        intents: Array.isArray(item.intents) ? item.intents : [],
        fields: Array.isArray(item.fields) ? item.fields : [],
        entities: typeof item.entities === 'string' 
          ? item.entities 
          : JSON.stringify(item.entities || {}),
        product: Array.isArray(item.product) 
          ? item.product 
          : typeof item.product === 'string' 
            ? [item.product] 
            : ["Jira Core"],
        why: item.why || "",
        notes: item.notes || ""
      }
      
      queries.push(query)
    } catch (error) {
      Logger.error(error, `Failed to process query item: ${JSON.stringify(item)}`)
    }
  }
  
  Logger.info(`Processed ${queries.length} queries from JSON data`)
  return queries
}

/**
 * Insert your sample JQL query
 */
export const insertSampleJQLQuery = async (): Promise<void> => {
  const sampleQuery: JQLQuery = {
    id: "A.1",
    section: "A. Basic Filters", 
    nlq: "Show me all open issues",
    jql: "status = Open",
    description: "Issues currently in the Open status.",
    query_summary: "Natural query: 'Show me all open issues'. Synonyms: tickets, items, bugs. Paraphrases: 'List open tickets', 'Open issues list', 'Give me active issues'. This JQL filters issues where the status field equals Open. Fields involved: status. Entity value: Open. Purpose: Useful for tracking ongoing work that has not been resolved yet.",
    synonyms: ["tickets", "items", "bugs"],
    paraphrases: ["List open tickets", "Open issues list", "Give me active issues"],
    intents: ["browse", "status"],
    fields: ["status"],
    entities: JSON.stringify({"status": "Open"}),
    product: ["Jira Core"],
    why: "Basic filter to identify active work items still marked as Open.",
    notes: "Ensure 'Open' matches your workflow; some instances may use 'In Progress'."
  }
  
  await insertJQLQuery(sampleQuery)
}

/**
 * Utility function to validate JQL query structure
 */
export const validateJQLQuery = (query: any): string[] => {
  const errors: string[] = []
  
  if (!query.id) errors.push("Missing required field: id")
  if (!query.nlq) errors.push("Missing required field: nlq")
  if (!query.jql) errors.push("Missing required field: jql")
  if (!query.description) errors.push("Missing required field: description")
  
  // Check array fields
  const arrayFields = ['synonyms', 'paraphrases', 'intents', 'fields', 'product']
  for (const field of arrayFields) {
    if (query[field] && !Array.isArray(query[field])) {
      errors.push(`Field '${field}' must be an array`)
    }
  }
  
  return errors
}

/**
 * Main function to handle different types of JQL data insertion
 */
export const handleJQLDataImport = async (
  data: JQLQuery | JQLQuery[] | any,
  options: {
    validate?: boolean
    skipErrors?: boolean
  } = {}
): Promise<JQLInsertResult> => {
  const { validate = true, skipErrors = true } = options
  
  try {
    let queries: JQLQuery[] = []
    
    // Handle different input types
    if (Array.isArray(data)) {
      queries = await loadJQLQueriesFromJSON(data)
    } else if (typeof data === 'object' && data.id) {
      queries = [data as JQLQuery]
    } else {
      throw new Error("Invalid data format. Expected JQLQuery or JQLQuery[]")
    }
    
    // Validate if requested
    if (validate) {
      for (const query of queries) {
        const validationErrors = validateJQLQuery(query)
        if (validationErrors.length > 0 && !skipErrors) {
          throw new Error(`Validation failed for query ${query.id}: ${validationErrors.join(', ')}`)
        }
      }
    }
    
    // Insert the queries
    return await insertJQLQueryBatch(queries)
    
  } catch (error) {
    Logger.error(error, "Failed to import JQL data")
    throw error
  }
}

// Export the schema constant for external use
export { JQL_QUERIES_SCHEMA, jqlQueriesSchema }